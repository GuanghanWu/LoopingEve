<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ˜æ–—æ¨¡æ‹Ÿå™¨ - LoopingEve</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #ecf0f1; padding: 20px; }
        h1 { text-align: center; margin-bottom: 20px; color: #f39c12; }
        .container { max-width: 1400px; margin: 0 auto; display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        .panel { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; }
        .panel h2 { margin-bottom: 15px; color: #3498db; font-size: 1.1rem; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px; }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; margin-bottom: 5px; color: #95a5a6; font-size: 0.85rem; }
        .form-group input, .form-group select { width: 100%; padding: 8px 12px; border: none; border-radius: 8px; background: rgba(0,0,0,0.3); color: #ecf0f1; font-size: 0.95rem; }
        .btn { width: 100%; padding: 12px; border: none; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 10px; }
        .btn-run { background: linear-gradient(45deg, #2ecc71, #27ae60); color: white; }
        .btn-run:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4); }
        .btn-reset { background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; }
        .results { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-bottom: 20px; }
        .stat-card { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 12px; text-align: center; }
        .stat-card .value { font-size: 1.8rem; font-weight: bold; color: #f39c12; }
        .stat-card .label { font-size: 0.75rem; color: #95a5a6; margin-top: 5px; }
        .stat-card.good .value { color: #2ecc71; }
        .stat-card.bad .value { color: #e74c3c; }
        .stat-card.funscore { grid-column: span 2; background: linear-gradient(135deg, rgba(243,156,18,0.2), rgba(231,76,60,0.2)); }
        .stat-card.funscore .value { font-size: 2.5rem; }
        .dimension-section { margin-bottom: 20px; }
        .dimension-section h3 { color: #f39c12; margin-bottom: 15px; font-size: 1rem; display: flex; align-items: center; gap: 10px; }
        .dimension-card { background: rgba(0,0,0,0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px; }
        .dimension-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .dimension-name { font-weight: bold; color: #3498db; }
        .dimension-score { font-size: 1.5rem; font-weight: bold; color: #f39c12; }
        .factor-list { font-size: 0.8rem; }
        .factor-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .factor-name { color: #95a5a6; }
        .factor-score { color: #2ecc71; }
        .factor-score.negative { color: #e74c3c; }
        .radar-container { display: flex; justify-content: center; margin-bottom: 20px; }
        .radar-chart { position: relative; width: 300px; height: 300px; }
        .radar-bg { position: absolute; width: 100%; height: 100%; }
        .radar-bg polygon { fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 1; }
        .radar-bg polygon:nth-child(5) { fill: rgba(255,255,255,0.05); }
        .radar-data { position: absolute; width: 100%; height: 100%; }
        .radar-data polygon { fill: rgba(243, 156, 18, 0.3); stroke: #f39c12; stroke-width: 2; }
        .radar-labels { position: absolute; width: 100%; height: 100%; }
        .radar-label { position: absolute; font-size: 0.8rem; color: #ecf0f1; text-align: center; width: 80px; }
        .radar-label .score { font-weight: bold; color: #f39c12; }
        .agent-selector { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px; }
        .agent-btn { flex: 1; padding: 8px; border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; background: rgba(0,0,0,0.3); color: #95a5a6; cursor: pointer; transition: all 0.2s; font-size: 0.8rem; }
        .agent-btn.active { background: linear-gradient(45deg, #3498db, #2980b9); border-color: #3498db; color: white; }
        .progress { margin-top: 10px; }
        .progress-bar { height: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); transition: width 0.3s; }
        .progress-text { text-align: center; font-size: 0.85rem; color: #95a5a6; margin-top: 5px; }
        .analysis { background: rgba(0,0,0,0.2); border-radius: 10px; padding: 15px; margin-top: 20px; }
        .analysis h3 { color: #f39c12; margin-bottom: 10px; }
        .analysis p { margin-bottom: 8px; font-size: 0.85rem; line-height: 1.5; }
        .analysis .warning { color: #e74c3c; }
        .analysis .success { color: #2ecc71; }
        .analysis .info { color: #3498db; }
        .threshold-legend { display: flex; gap: 15px; justify-content: center; margin-top: 10px; font-size: 0.75rem; }
        .threshold-item { display: flex; align-items: center; gap: 5px; }
        .threshold-color { width: 12px; height: 12px; border-radius: 3px; }
        .log { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.75rem; }
        .log p { margin-bottom: 3px; }
        .log .win { color: #2ecc71; }
        .log .lose { color: #e74c3c; }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <h1>ğŸ® LoopingEve æˆ˜æ–—æ¨¡æ‹Ÿå™¨ v4.0</h1>
    <div class="container">
        <div class="panel config-panel">
            <h2>âš™ï¸ æ¨¡æ‹Ÿé…ç½®</h2>
            <div class="form-group">
                <label>æ¨¡æ‹Ÿæ¬¡æ•°</label>
                <input type="number" id="simCount" value="1000" min="100" max="10000">
            </div>
            <div class="form-group">
                <label>ç›®æ ‡å±‚æ•°</label>
                <input type="number" id="targetFloor" value="10" min="1" max="100">
            </div>
            <div class="form-group">
                <label>ç©å®¶ç±»å‹</label>
                <div class="agent-selector">
                    <button class="agent-btn active" data-agent="casual">è½»åº¦ä¼‘é—²</button>
                    <button class="agent-btn" data-agent="hardcore">ç¡¬æ ¸ç«æŠ€</button>
                    <button class="agent-btn" data-agent="explorer">å‰§æƒ…æ¢ç´¢</button>
                    <button class="agent-btn" data-agent="social">ç¤¾äº¤äº’åŠ¨</button>
                    <button class="agent-btn" data-agent="paying">ä»˜è´¹ä¹ æƒ¯</button>
                </div>
            </div>
            <div class="form-group">
                <label>ç­–ç•¥ï¼šè¡€ç“¶ä½¿ç”¨</label>
                <select id="potionStrategy">
                    <option value="never">ä»ä¸ä½¿ç”¨</option>
                    <option value="lowHp">HP&lt;30%æ—¶ä½¿ç”¨</option>
                    <option value="always">HPä¸æ»¡å°±ç”¨</option>
                </select>
            </div>
            <div class="form-group">
                <label>ç­–ç•¥ï¼šæŠ€èƒ½ä½¿ç”¨</label>
                <select id="skillStrategy">
                    <option value="always">å†·å´ç»“æŸå°±ç”¨</option>
                    <option value="boss">åªå¯¹é«˜HPæ€ªç‰©ç”¨</option>
                    <option value="never">ä»ä¸ä½¿ç”¨</option>
                </select>
            </div>
            <div class="form-group">
                <label>ç­–ç•¥ï¼šé”»é€ è£…å¤‡</label>
                <select id="forgeStrategy">
                    <option value="always">ææ–™å¤Ÿå°±é”»é€ </option>
                    <option value="weapon">åªé”»é€ æ­¦å™¨</option>
                    <option value="armor">åªé”»é€ ç”²èƒ„</option>
                    <option value="never">ä»ä¸é”»é€ </option>
                </select>
            </div>
            <button class="btn btn-run" onclick="runSimulation()">ğŸš€ å¼€å§‹æ¨¡æ‹Ÿ</button>
            <button class="btn btn-reset" onclick="resetResults()">ğŸ”„ é‡ç½®</button>
            <div class="progress" id="progress" style="display:none;">
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
        </div>
        <div class="panel results-panel">
            <h2>ğŸ“Š æ¨¡æ‹Ÿç»“æœ</h2>
            <div class="results">
                <div class="stat-card funscore">
                    <div class="value" id="funScore">-</div>
                    <div class="label">ğŸ® ç»¼åˆçˆ½æ„ŸæŒ‡æ•°</div>
                </div>
                <div class="stat-card" id="winRateCard">
                    <div class="value" id="winRate">-</div>
                    <div class="label">é€šå…³ç‡</div>
                </div>
                <div class="stat-card">
                    <div class="value" id="avgFloor">-</div>
                    <div class="label">å¹³å‡å±‚æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="value" id="avgLevel">-</div>
                    <div class="label">å¹³å‡ç­‰çº§</div>
                </div>
                <div class="stat-card">
                    <div class="value" id="avgKills">-</div>
                    <div class="label">å¹³å‡å‡»æ€</div>
                </div>
            </div>
            <div class="threshold-legend">
                <div class="threshold-item"><div class="threshold-color" style="background:#e74c3c"></div>Critical(&lt;3)</div>
                <div class="threshold-item"><div class="threshold-color" style="background:#f39c12"></div>Warning(3-4.5)</div>
                <div class="threshold-item"><div class="threshold-color" style="background:#3498db"></div>Good(4.5-6)</div>
                <div class="threshold-item"><div class="threshold-color" style="background:#2ecc71"></div>Excellent(&gt;6)</div>
            </div>
            <div class="radar-container">
                <svg class="radar-chart" viewBox="0 0 300 300" id="radarChart">
                    <g class="radar-bg">
                        <polygon points="150,30 270,110 230,250 70,250 30,110"/>
                        <polygon points="150,54 246,118 214,238 86,238 54,118"/>
                        <polygon points="150,78 222,126 198,226 102,226 78,126"/>
                        <polygon points="150,102 198,134 182,214 118,214 102,134"/>
                        <polygon points="150,126 174,142 166,202 134,202 126,142"/>
                    </g>
                    <polygon class="radar-data" id="radarData" points="150,150 150,150 150,150 150,150 150,150"/>
                    <g class="radar-labels" id="radarLabels"></g>
                </svg>
            </div>
            <div id="dimensionsContainer"></div>
            <div class="analysis" id="analysis">
                <h3>ğŸ’¡ æ•°å€¼åˆ†æå»ºè®®</h3>
                <p>ç‚¹å‡»"å¼€å§‹æ¨¡æ‹Ÿ"è·å–åˆ†æç»“æœ...</p>
            </div>
        </div>
    </div>
    <div class="panel" style="max-width: 1400px; margin: 20px auto;">
        <h2>ğŸ“ è¯¦ç»†æ—¥å¿—ï¼ˆæœ€è¿‘50åœºï¼‰</h2>
        <div class="log" id="log"></div>
    </div>

    <script>
        // åŠ è½½evaluationé…ç½®
        let EVALUATION_CONFIG = null;
        let GAME_CONFIG = null;
        
        async function loadConfigs() {
            const [evalRes, gameRes] = await Promise.all([
                fetch('../../CrowdAgents/config/evaluation.json'),
                fetch('../../config.json')
            ]);
            EVALUATION_CONFIG = await evalRes.json();
            GAME_CONFIG = await gameRes.json();
        }
        loadConfigs();

        // å½“å‰é€‰ä¸­çš„ç©å®¶ç±»å‹
        let currentAgent = 'casual';

        // ç©å®¶ç±»å‹åˆ‡æ¢
        document.querySelectorAll('.agent-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.agent-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentAgent = this.dataset.agent;
            });
        });

        // è¯„åˆ†è®¡ç®—å™¨ç±»
        class EvaluationScorer {
            constructor() {
                this.reset();
            }

            reset() {
                // ä¸ºæ¯ä¸ªç»´åº¦è·Ÿè¸ªå› å­çš„è§¦å‘æ¬¡æ•°å’Œç´¯è®¡åˆ†æ•°
                this.dimensionFactors = {};
                for (const dim of Object.keys(EVALUATION_CONFIG.factors)) {
                    this.dimensionFactors[dim] = {
                        positive: {},
                        negative: {}
                    };
                }
                this.battleCount = 0;
                this.sessionTime = 0;
            }

            // è®°å½•å› å­è§¦å‘
            recordFactor(dimension, factorName, isPositive = true) {
                const dimConfig = EVALUATION_CONFIG.factors[dimension];
                if (!dimConfig) return 0;

                const category = isPositive ? 'positive' : 'negative';
                const factorConfig = dimConfig[category][factorName];
                if (!factorConfig) return 0;

                // åˆå§‹åŒ–è·Ÿè¸ª
                if (!this.dimensionFactors[dimension][category][factorName]) {
                    this.dimensionFactors[dimension][category][factorName] = {
                        count: 0,
                        totalScore: 0
                    };
                }

                const tracker = this.dimensionFactors[dimension][category][factorName];
                
                // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§ç´¯ç§¯
                if (tracker.totalScore >= factorConfig.maxAccumulated) {
                    return 0;
                }

                // è®¡ç®—åŸºç¡€åˆ†
                let score = factorConfig.baseScore;
                
                // åº”ç”¨é¢‘ç‡ä¹˜æ•°
                const freqMultiplier = EVALUATION_CONFIG.frequencyMultipliers[factorConfig.frequency].baseMultiplier;
                score *= freqMultiplier;

                // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§ç´¯ç§¯
                const remaining = factorConfig.maxAccumulated - tracker.totalScore;
                score = Math.min(score, remaining);

                tracker.count++;
                tracker.totalScore += score;

                return score;
            }

            // è®¡ç®—å•ä¸ªç»´åº¦åˆ†æ•°
            calculateDimensionScore(dimension) {
                const factors = this.dimensionFactors[dimension];
                let positiveScore = 0;
                let negativeScore = 0;

                // ç´¯åŠ æ­£é¢å› å­
                for (const [name, tracker] of Object.entries(factors.positive)) {
                    positiveScore += tracker.totalScore;
                }

                // ç´¯åŠ è´Ÿé¢å› å­
                for (const [name, tracker] of Object.entries(factors.negative)) {
                    negativeScore += tracker.totalScore;
                }

                // åº”ç”¨æ­£åˆ™åŒ–è§„åˆ™
                const reg = EVALUATION_CONFIG.regularization;
                let finalScore = reg.baseScore + positiveScore - negativeScore;
                
                // é™åˆ¶åœ¨æœ‰æ•ˆèŒƒå›´å†…
                finalScore = Math.max(0, Math.min(10, finalScore));

                return {
                    score: finalScore,
                    positive: positiveScore,
                    negative: negativeScore,
                    factors: factors
                };
            }

            // è®¡ç®—æ‰€æœ‰ç»´åº¦åˆ†æ•°
            calculateAllDimensions() {
                const results = {};
                for (const dim of Object.keys(EVALUATION_CONFIG.factors)) {
                    results[dim] = this.calculateDimensionScore(dim);
                }
                return results;
            }

            // è®¡ç®—ç»¼åˆçˆ½æ„Ÿåˆ†æ•°
            calculateFunScore(agentType = 'casual') {
                const dimensions = this.calculateAllDimensions();
                const weights = EVALUATION_CONFIG.agentWeights[agentType];
                
                let totalScore = 0;
                let totalWeight = 0;

                for (const [dim, data] of Object.entries(dimensions)) {
                    const weight = weights[dim] || 1.0;
                    totalScore += data.score * weight;
                    totalWeight += weight;
                }

                return {
                    total: totalScore / totalWeight,
                    dimensions: dimensions
                };
            }
        }

        // æ¨¡æ‹Ÿç©å®¶ç±»
        class SimPlayer {
            constructor() {
                Object.assign(this, { ...GAME_CONFIG.player.initial });
                this.weaponAtk = 0;
                this.armorDef = 0;
                this.potions = { smallPotion: 3, mediumPotion: 0, largePotion: 0 };
                this.materials = {};
                this.learnedSkills = ['powerStrike'];
                this.skillCooldowns = {};
                this.totalDamageDealt = 0;
                this.totalDamageTaken = 0;
                this.totalHealed = 0;
                this.goldSpent = 0;
                this.potionsUsed = 0;
                this.skillsUsed = 0;
                this.levelUps = 0;
                this.battleCount = 0;
                this.thrillBattles = 0;
                this.comebackWins = 0;
                this.goodLengthBattles = 0;
                this.totalTurns = 0;
                this.itemsForged = 0;
                this.monstersKilled = [];
                this.skillsUsedInBattle = new Set();
                this.consecutiveWins = 0;
                this.consecutiveFails = 0;
                this.battlesWithoutLoot = 0;
                this.startTime = Date.now();
            }
            
            getTotalAtk() { return this.atk + this.weaponAtk; }
            getTotalDef() { return this.def + this.armorDef; }
            
            levelUp() {
                const cfg = GAME_CONFIG.player.levelUp;
                this.level++;
                this.maxHP += cfg.hp;
                this.hp = Math.min(this.hp + cfg.hp, this.maxHP);
                this.atk += cfg.atk;
                this.def += cfg.def;
                this.maxEXP = Math.floor(this.maxEXP * cfg.expMultiplier);
                this.levelUps++;
                if (this.level >= 3 && !this.learnedSkills.includes('heal')) {
                    this.learnedSkills.push('heal');
                }
            }
            
            usePotion() {
                if (this.potions.largePotion > 0) {
                    this.potions.largePotion--;
                    const heal = GAME_CONFIG.items.consumables.find(i => i.id === 'largePotion').heal;
                    this.hp = Math.min(this.hp + heal, this.maxHP);
                    this.totalHealed += heal;
                    this.potionsUsed++;
                    return true;
                }
                if (this.potions.mediumPotion > 0) {
                    this.potions.mediumPotion--;
                    const heal = GAME_CONFIG.items.consumables.find(i => i.id === 'mediumPotion').heal;
                    this.hp = Math.min(this.hp + heal, this.maxHP);
                    this.totalHealed += heal;
                    this.potionsUsed++;
                    return true;
                }
                if (this.potions.smallPotion > 0) {
                    this.potions.smallPotion--;
                    const heal = GAME_CONFIG.items.consumables.find(i => i.id === 'smallPotion').heal;
                    this.hp = Math.min(this.hp + heal, this.maxHP);
                    this.totalHealed += heal;
                    this.potionsUsed++;
                    return true;
                }
                return false;
            }

            getPlayTime() {
                return (Date.now() - this.startTime) / 1000;
            }
        }

        // æ¨¡æ‹Ÿå™¨ç±»
        class Simulator {
            constructor(strategy) {
                this.strategy = strategy;
                this.results = [];
                this.floorDeaths = {};
                this.scorer = new EvaluationScorer();
                this.totalStats = { 
                    wins: 0, floors: 0, levels: 0, gold: 0, kills: 0, levelUps: 0, battles: 0, 
                    thrillBattles: 0, comebackWins: 0, goodLengthBattles: 0, totalTurns: 0, 
                    totalHealed: 0, goldSpent: 0, itemsForged: 0 
                };
            }

            createMonster(floor) {
                const monsters = GAME_CONFIG.monsters.filter(m => m.minFloor <= floor);
                const m = monsters[Math.floor(Math.random() * monsters.length)];
                const mult = 1 + (floor - 1) * GAME_CONFIG.floor.difficultyMultiplier;
                return {
                    name: m.name, avatar: m.avatar,
                    hp: Math.floor(m.hp * mult), maxHP: Math.floor(m.hp * mult),
                    atk: Math.floor(m.atk * mult), def: Math.floor(m.def * mult),
                    exp: Math.floor(m.exp * mult), gold: Math.floor(m.gold * mult),
                    isBoss: m.isBoss || false
                };
            }

            calcDamage(atk, def, rand) {
                return Math.max(1, Math.floor(atk - def + Math.random() * rand));
            }

            getSkill(skillId) {
                return GAME_CONFIG.skills.find(s => s.id === skillId);
            }

            simulateBattle(player, monster, floor) {
                const battle = { player, monster, turns: 0, playerDmg: 0, monsterDmg: 0, wasLowHp: false };
                player.battleCount++;
                this.scorer.battleCount++;
                player.skillsUsedInBattle.clear();
                
                while (player.hp > 0 && monster.hp > 0 && battle.turns < 100) {
                    battle.turns++;
                    const useSkill = this.strategy.skill === 'always' && 
                        player.learnedSkills.includes('powerStrike') && 
                        (player.skillCooldowns['powerStrike'] || 0) === 0;
                    
                    if (useSkill) {
                        const skill = this.getSkill('powerStrike');
                        const dmg = this.calcDamage(player.getTotalAtk() * skill.damageMultiplier, monster.def, skill.damageRand);
                        monster.hp -= dmg;
                        player.totalDamageDealt += dmg;
                        battle.playerDmg += dmg;
                        player.skillsUsed++;
                        player.skillsUsedInBattle.add('powerStrike');
                        player.skillCooldowns['powerStrike'] = skill.cd;
                        
                        // è®°å½•æŠ€èƒ½ä½¿ç”¨å› å­
                        this.scorer.recordFactor('playability', 'skillUse', true);
                    } else {
                        const dmg = this.calcDamage(player.getTotalAtk(), monster.def, GAME_CONFIG.battle.normalAttackRand);
                        monster.hp -= dmg;
                        player.totalDamageDealt += dmg;
                        battle.playerDmg += dmg;
                    }
                    
                    Object.keys(player.skillCooldowns).forEach(k => {
                        if (player.skillCooldowns[k] > 0) player.skillCooldowns[k]--;
                    });
                    
                    if (monster.hp <= 0) break;
                    
                    const enemyDmg = this.calcDamage(monster.atk, player.getTotalDef(), GAME_CONFIG.battle.enemyAttackRand);
                    player.hp -= enemyDmg;
                    player.totalDamageTaken += enemyDmg;
                    battle.monsterDmg += enemyDmg;
                    
                    if (player.hp < player.maxHP * 0.3) battle.wasLowHp = true;
                    
                    const healThreshold = player.maxHP * 0.3;
                    if (this.strategy.potion === 'lowHp' && player.hp < healThreshold) {
                        player.usePotion();
                    } else if (this.strategy.potion === 'always' && player.hp < player.maxHP) {
                        player.usePotion();
                    }
                }
                
                player.totalTurns += battle.turns;
                if (battle.wasLowHp) player.thrillBattles++;
                if (battle.wasLowHp && player.hp > 0) player.comebackWins++;
                if (battle.turns >= 3 && battle.turns <= 8) player.goodLengthBattles++;

                // è®°å½•æˆ˜æ–—ç›¸å…³å› å­
                this.recordBattleFactors(player, monster, battle, floor);
                
                return battle;
            }

            recordBattleFactors(player, monster, battle, floor) {
                const won = player.hp > 0;
                const hpRatio = player.hp / player.maxHP;

                // åˆºæ¿€åº¦å› å­
                if (won && hpRatio < 0.2) {
                    this.scorer.recordFactor('excitement', 'closeVictory', true);
                }
                if (battle.wasLowHp && won) {
                    this.scorer.recordFactor('excitement', 'comeback', true);
                }
                if (hpRatio < 0.3) {
                    this.scorer.recordFactor('excitement', 'lowHPBattle', true);
                }
                if (battle.turns === 1 && won) {
                    this.scorer.recordFactor('excitement', 'oneHitKill', true);
                }
                if (monster.isBoss) {
                    this.scorer.recordFactor('excitement', 'bossFight', true);
                }
                if (floor >= 8) {
                    this.scorer.recordFactor('excitement', 'highFloor', true);
                }
                if (battle.turns > 30) {
                    this.scorer.recordFactor('excitement', 'battleDrag', false);
                }

                // èŠ‚å¥æ„Ÿå› å­
                if (battle.turns < 10) {
                    this.scorer.recordFactor('pacing', 'quickBattle', true);
                }
                if (battle.turns >= 5 && battle.turns <= 15) {
                    this.scorer.recordFactor('pacing', 'idealBattleTime', true);
                }
                if (battle.turns > 30) {
                    this.scorer.recordFactor('pacing', 'battleTooLong', false);
                }

                // å¯ç©æ€§å› å­
                if (player.skillsUsedInBattle.size >= 1) {
                    this.scorer.recordFactor('playability', 'skillUse', true);
                }
                if (player.skillsUsedInBattle.size >= 3) {
                    this.scorer.recordFactor('playability', 'diversePlaystyle', true);
                }
                if (!player.monstersKilled.includes(monster.name)) {
                    this.scorer.recordFactor('playability', 'newMonster', true);
                    player.monstersKilled.push(monster.name);
                }

                // ç•™å­˜å› å­
                if (won) {
                    player.consecutiveWins++;
                    player.consecutiveFails = 0;
                    if (player.consecutiveWins >= 3) {
                        this.scorer.recordFactor('retention', 'winStreak', true);
                    }
                } else {
                    player.consecutiveFails++;
                    player.consecutiveWins = 0;
                    if (player.consecutiveFails >= 2) {
                        this.scorer.recordFactor('retention', 'failStreak', false);
                    }
                }
            }

            grantLoot(player, monster, floor) {
                const lootTable = GAME_CONFIG.lootTable[monster.name];
                if (!lootTable) return false;
                
                let gotLoot = false;
                lootTable.forEach(loot => {
                    if (Math.random() < loot.rate) {
                        gotLoot = true;
                        const count = Math.floor(Math.random() * (loot.maxCount - loot.minCount + 1)) + loot.minCount;
                        const consumable = GAME_CONFIG.items.consumables.find(i => i.id === loot.itemId);
                        if (consumable) {
                            if (player.potions[loot.itemId] !== undefined) {
                                player.potions[loot.itemId] += count;
                            }
                        } else {
                            if (!player.materials[loot.itemId]) player.materials[loot.itemId] = 0;
                            player.materials[loot.itemId] += count;
                        }
                    }
                });

                if (gotLoot) {
                    player.battlesWithoutLoot = 0;
                    this.scorer.recordFactor('growth', 'commonItem', true);
                } else {
                    player.battlesWithoutLoot++;
                    if (player.battlesWithoutLoot >= 5) {
                        this.scorer.recordFactor('retention', 'noLootStreak', false);
                    }
                }

                return gotLoot;
            }

            tryForge(player) {
                if (this.strategy.forge === 'never') return false;
                
                let forged = false;
                const checkCategory = (category, type) => {
                    const items = GAME_CONFIG.equipment[category];
                    for (const item of items) {
                        const currentVal = type === 'atk' ? player.weaponAtk : player.armorDef;
                        const itemVal = type === 'atk' ? item.atk : item.def;
                        if (itemVal <= currentVal) continue;
                        
                        let canForge = true;
                        for (const [matId, count] of Object.entries(item.materials)) {
                            if ((player.materials[matId] || 0) < count) {
                                canForge = false;
                                break;
                            }
                        }
                        
                        if (canForge) {
                            for (const [matId, count] of Object.entries(item.materials)) {
                                player.materials[matId] -= count;
                            }
                            if (type === 'atk') player.weaponAtk = itemVal;
                            else player.armorDef = itemVal;
                            player.itemsForged++;
                            forged = true;
                            
                            // è®°å½•é”»é€ å› å­
                            this.scorer.recordFactor('growth', 'forgeSuccess', true);
                            this.scorer.recordFactor('playability', 'forgeSuccess', true);
                            return true;
                        }
                    }
                    return false;
                };
                
                if (this.strategy.forge === 'always' || this.strategy.forge === 'weapon') {
                    checkCategory('weapons', 'atk');
                }
                if (this.strategy.forge === 'always' || this.strategy.forge === 'armor') {
                    checkCategory('armors', 'def');
                }

                return forged;
            }

            runOne(targetFloor) {
                const player = new SimPlayer();
                let floor = 1;
                let kills = 0;
                let killedOnFloor = 0;
                
                while (player.hp > 0 && floor <= targetFloor) {
                    const monster = this.createMonster(floor);
                    const battle = this.simulateBattle(player, monster, floor);
                    
                    if (player.hp <= 0) {
                        this.floorDeaths[floor] = (this.floorDeaths[floor] || 0) + 1;
                        
                        // è®°å½•æ­»äº¡å› å­
                        this.scorer.recordFactor('retention', 'death', false);
                        this.scorer.recordFactor('excitement', 'death', false);
                        
                        return {
                            win: false, floor, level: player.level, gold: player.gold,
                            kills, player, deathMonster: monster.name
                        };
                    }
                    
                    kills++;
                    killedOnFloor++;
                    player.exp += monster.exp;
                    player.gold += monster.gold;
                    
                    const prevLevel = player.level;
                    while (player.exp >= player.maxEXP) player.levelUp();
                    if (player.level > prevLevel) {
                        // è®°å½•å‡çº§å› å­
                        this.scorer.recordFactor('growth', 'levelUp', true);
                        this.scorer.recordFactor('growth', 'battleVictory', true);
                    }
                    
                    this.grantLoot(player, monster, floor);
                    this.tryForge(player);
                    
                    if (killedOnFloor >= GAME_CONFIG.floor.monstersToAdvance) {
                        // è®°å½•æ¥¼å±‚æ¨è¿›å› å­
                        this.scorer.recordFactor('retention', 'newFloor', true);
                        this.scorer.recordFactor('pacing', 'progressVisible', true);
                        
                        floor++;
                        killedOnFloor = 0;
                    }
                }
                
                return {
                    win: floor > targetFloor, floor: floor - 1, level: player.level,
                    gold: player.gold, kills, player
                };
            }

            run(count, targetFloor, onProgress) {
                this.scorer.reset();
                
                for (let i = 0; i < count; i++) {
                    const result = this.runOne(targetFloor);
                    this.results.push(result);
                    const p = result.player;
                    if (result.win) this.totalStats.wins++;
                    this.totalStats.floors += result.floor;
                    this.totalStats.levels += result.level;
                    this.totalStats.gold += result.gold;
                    this.totalStats.kills += result.kills;
                    this.totalStats.levelUps += p.levelUps;
                    this.totalStats.battles += p.battleCount;
                    this.totalStats.thrillBattles += p.thrillBattles;
                    this.totalStats.comebackWins += p.comebackWins;
                    this.totalStats.goodLengthBattles += p.goodLengthBattles;
                    this.totalStats.totalTurns += p.totalTurns;
                    this.totalStats.totalHealed += p.totalHealed;
                    this.totalStats.goldSpent += p.goldSpent;
                    this.totalStats.itemsForged += p.itemsForged;
                    if (onProgress && i % 100 === 0) onProgress(i / count);
                }
                if (onProgress) onProgress(1);
                
                // è®¡ç®—æœ€ç»ˆè¯„åˆ†
                const funResult = this.scorer.calculateFunScore(currentAgent);
                
                return {
                    winRate: (this.totalStats.wins / count * 100).toFixed(1),
                    avgFloor: (this.totalStats.floors / count).toFixed(1),
                    avgLevel: (this.totalStats.levels / count).toFixed(1),
                    avgGold: Math.floor(this.totalStats.gold / count),
                    avgKills: Math.floor(this.totalStats.kills / count),
                    funScore: funResult.total.toFixed(2),
                    funMetrics: funResult.dimensions,
                    floorDeaths: this.floorDeaths,
                    avgForged: (this.totalStats.itemsForged / count).toFixed(1),
                    results: this.results
                };
            }
        }

        async function runSimulation() {
            if (!EVALUATION_CONFIG || !GAME_CONFIG) { 
                alert('é…ç½®æœªåŠ è½½ï¼Œè¯·ç¨åå†è¯•'); 
                return; 
            }
            
            const count = parseInt(document.getElementById('simCount').value);
            const targetFloor = parseInt(document.getElementById('targetFloor').value);
            const strategy = {
                potion: document.getElementById('potionStrategy').value,
                skill: document.getElementById('skillStrategy').value,
                forge: document.getElementById('forgeStrategy').value
            };
            
            document.getElementById('progress').style.display = 'block';
            const sim = new Simulator(strategy);
            const stats = sim.run(count, targetFloor, (p) => {
                document.getElementById('progressFill').style.width = (p * 100) + '%';
                document.getElementById('progressText').textContent = Math.floor(p * 100) + '%';
            });
            
            updateUI(stats, sim.results.slice(-50), sim.totalStats);
            analyzeResults(stats);
        }

        function updateUI(stats, recentResults, totalStats) {
            const funScore = parseFloat(stats.funScore);
            document.getElementById('funScore').textContent = stats.funScore;
            document.getElementById('funScore').parentElement.className = 'stat-card funscore ' + (funScore >= 6 ? 'good' : funScore < 3 ? 'bad' : '');
            
            const winRate = parseFloat(stats.winRate);
            document.getElementById('winRate').textContent = stats.winRate + '%';
            document.getElementById('winRateCard').className = 'stat-card ' + (winRate > 50 ? 'good' : winRate > 20 ? '' : 'bad');
            
            document.getElementById('avgFloor').textContent = stats.avgFloor;
            document.getElementById('avgLevel').textContent = stats.avgLevel;
            document.getElementById('avgKills').textContent = stats.avgKills;
            
            updateRadar(stats.funMetrics);
            updateDimensions(stats.funMetrics);
            
            const log = document.getElementById('log');
            log.innerHTML = recentResults.map(r => 
                `<p class="${r.win ? 'win' : 'lose'}">${r.win ? 'âœ“' : 'âœ—'} F${r.floor} Lv${r.level} ğŸ’°${r.gold} âš”${r.kills}${r.deathMonster ? ' ğŸ’€'+r.deathMonster : ''}</p>`
            ).join('');
        }

        function updateRadar(dimensions) {
            const dimNames = ['growth', 'control', 'excitement', 'reward', 'pacing'];
            const labels = [
                { name: 'æˆé•¿æ„Ÿ', angle: -90 },
                { name: 'æŒæ§æ„Ÿ', angle: -18 },
                { name: 'åˆºæ¿€æ„Ÿ', angle: 54 },
                { name: 'å¥–åŠ±æ„Ÿ', angle: 126 },
                { name: 'èŠ‚å¥æ„Ÿ', angle: 198 }
            ];
            
            const centerX = 150, centerY = 150, maxR = 120;
            
            const points = labels.map((l, i) => {
                const rad = l.angle * Math.PI / 180;
                const score = dimensions[dimNames[i]]?.score || 0;
                const r = (score / 10) * maxR;
                return `${centerX + r * Math.cos(rad)},${centerY + r * Math.sin(rad)}`;
            }).join(' ');
            
            document.getElementById('radarData').setAttribute('points', points);
            
            const labelsHtml = labels.map((l, i) => {
                const rad = l.angle * Math.PI / 180;
                const labelR = maxR + 30;
                const x = centerX + labelR * Math.cos(rad);
                const y = centerY + labelR * Math.sin(rad);
                const score = dimensions[dimNames[i]]?.score || 0;
                const color = score >= 6 ? '#2ecc71' : score < 3 ? '#e74c3c' : '#f39c12';
                return `<div class="radar-label" style="left:${x-40}px;top:${y-12}px"><span class="score" style="color:${color}">${score.toFixed(1)}</span><br>${l.name}</div>`;
            }).join('');
            document.getElementById('radarLabels').innerHTML = labelsHtml;
        }

        function updateDimensions(dimensions) {
            const container = document.getElementById('dimensionsContainer');
            const dimConfig = EVALUATION_CONFIG.dimensionNames;
            
            let html = '<div class="dimension-section"><h3>ğŸ“Š ç»´åº¦è¯¦ç»†åˆ†æ</h3>';
            
            for (const [dimKey, dimData] of Object.entries(dimensions)) {
                const dimName = dimConfig[dimKey] || dimKey;
                const score = dimData.score.toFixed(2);
                const scoreClass = dimData.score >= 6 ? 'good' : dimData.score < 3 ? 'bad' : '';
                
                html += `
                    <div class="dimension-card">
                        <div class="dimension-header">
                            <span class="dimension-name">${dimName}</span>
                            <span class="dimension-score ${scoreClass}">${score}/10</span>
                        </div>
                        <div class="factor-list">
                `;
                
                // æ­£é¢å› å­
                for (const [factorName, tracker] of Object.entries(dimData.factors.positive)) {
                    if (tracker.count > 0) {
                        html += `<div class="factor-item"><span class="factor-name">âœ“ ${factorName} (Ã—${tracker.count})</span><span class="factor-score">+${tracker.totalScore.toFixed(2)}</span></div>`;
                    }
                }
                
                // è´Ÿé¢å› å­
                for (const [factorName, tracker] of Object.entries(dimData.factors.negative)) {
                    if (tracker.count > 0) {
                        html += `<div class="factor-item"><span class="factor-name">âœ— ${factorName} (Ã—${tracker.count})</span><span class="factor-score negative">-${tracker.totalScore.toFixed(2)}</span></div>`;
                    }
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function analyzeResults(stats) {
            const analysis = document.getElementById('analysis');
            const issues = [];
            const suggestions = [];
            const thresholds = EVALUATION_CONFIG.thresholds;
            
            const funScore = parseFloat(stats.funScore);
            
            // ç»¼åˆè¯„åˆ†åˆ†æ
            if (funScore >= thresholds.excellent) {
                issues.push(`<p class="success">ğŸ‰ ç»¼åˆçˆ½æ„ŸæŒ‡æ•° ${stats.funScore}ï¼Œæ¸¸æˆä½“éªŒä¼˜ç§€ï¼</p>`);
            } else if (funScore >= thresholds.good) {
                issues.push(`<p class="success">ğŸ“Š ç»¼åˆçˆ½æ„ŸæŒ‡æ•° ${stats.funScore}ï¼Œæ¸¸æˆä½“éªŒè‰¯å¥½</p>`);
            } else if (funScore >= thresholds.warning) {
                issues.push(`<p class="info">ğŸ“Š ç»¼åˆçˆ½æ„ŸæŒ‡æ•° ${stats.funScore}ï¼Œæœ‰æå‡ç©ºé—´</p>`);
            } else if (funScore >= thresholds.critical) {
                issues.push(`<p class="warning">âš ï¸ ç»¼åˆçˆ½æ„ŸæŒ‡æ•° ${stats.funScore}ï¼Œéœ€è¦è°ƒæ•´æ•°å€¼</p>`);
            } else {
                issues.push(`<p class="warning">ğŸš¨ ç»¼åˆçˆ½æ„ŸæŒ‡æ•° ${stats.funScore}ï¼Œæ¸¸æˆä½“éªŒè¾ƒå·®ï¼Œæ€¥éœ€ä¼˜åŒ–</p>`);
            }
            
            // å„ç»´åº¦åˆ†æ
            for (const [dimKey, dimData] of Object.entries(stats.funMetrics)) {
                const dimName = EVALUATION_CONFIG.dimensionNames[dimKey] || dimKey;
                const score = dimData.score;
                
                if (score < thresholds.critical) {
                    issues.push(`<p class="warning">ğŸš¨ ${dimName}ä¸¥é‡ä¸è¶³(${score.toFixed(1)})</p>`);
                } else if (score < thresholds.warning) {
                    issues.push(`<p class="warning">âš ï¸ ${dimName}åä½(${score.toFixed(1)})</p>`);
                }
            }
            
            analysis.innerHTML = '<h3>ğŸ’¡ æ•°å€¼åˆ†æå»ºè®®</h3>' + issues.join('') + suggestions.join('');
        }

        function resetResults() {
            document.getElementById('funScore').textContent = '-';
            document.getElementById('winRate').textContent = '-';
            document.getElementById('avgFloor').textContent = '-';
            document.getElementById('avgLevel').textContent = '-';
            document.getElementById('avgKills').textContent = '-';
            document.getElementById('dimensionsContainer').innerHTML = '';
            document.getElementById('log').innerHTML = '';
            document.getElementById('analysis').innerHTML = '<h3>ğŸ’¡ æ•°å€¼åˆ†æå»ºè®®</h3><p>ç‚¹å‡»"å¼€å§‹æ¨¡æ‹Ÿ"è·å–åˆ†æç»“æœ...</p>';
            document.getElementById('progress').style.display = 'none';
            document.getElementById('radarData').setAttribute('points', '150,150 150,150 150,150 150,150 150,150');
            document.getElementById('radarLabels').innerHTML = '';
        }
    </script>
</body>
</html>